
    res.json({ image: savedImage });

  } catch (error) {
    console.error('âŒ Generation error:', error);
    if (axios.isAxiosError(error)) {
      console.error('Axios Error Status:', error.response?.status);
      console.error('Axios Error Data:', JSON.stringify(error.response?.data, null, 2));
    }
    res.status(500).json({
      error: 'Falha ao gerar imagem: ' + (error.message || 'Erro desconhecido'),
      details: error.response?.data || error.message
    });
  }
});

// 2. Check Quota Endpoint
app.get('/api/check-quota', async (req, res) => {
  try {
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    // Fetch user role
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    const role = profile?.role || 'free';

    // Fetch usage
    const { data: usageData } = await supabase
      .from('user_usage')
      .select('*')
      .eq('user_id', user.id)
      .single();

    const usageCount = usageData?.images_generated || 0;
    const limit = role === 'pro' ? 50 : (role === 'starter' ? 20 : 3);

    let status = 'OK';
    if (usageCount >= limit) status = 'BLOCKED';
    else if (usageCount >= limit * 0.8) status = 'NEAR_LIMIT';

    // UNLIMITED for owner/dev
    if (role === 'owner' || role === 'dev') status = 'OK';

    res.json({
      status,
      usage: {
        user_id: user.id,
        plan_id: role,
        cycle_start_date: new Date().toISOString(),
        current_usage: usageCount
      },
      plan: {
        id: role,
        price: 0,
        max_images_per_month: limit
      },
      plans: [],
      message: status === 'BLOCKED' ? 'Limite de geraÃ§Ã£o atingido' : 'Tudo certo!'
    });

  } catch (error) {
    console.error('Quota Check Error:', error);
    res.status(500).json({ error: 'Erro ao verificar cota' });
  }
});

// 3. Mercado Pago: Admin Connect (OAuth)
app.get('/api/admin/mp-connect', async (req, res) => {
  try {
    if (!MP_CLIENT_ID || !MP_REDIRECT_URI) {
      return res.status(500).json({ error: 'Mercado Pago nÃ£o configurado' });
    }

    const state = uuidv4();
    const url = `https://auth.mercadopago.com/authorization?client_id=${MP_CLIENT_ID}&response_type=code&platform_id=mp&state=${state}&redirect_uri=${encodeURIComponent(MP_REDIRECT_URI)}`;

    res.json({ connectUrl: url });
  } catch (error) {
    console.error('MP Connect Error:', error);
    res.status(500).json({ error: 'Erro ao gerar URL de conexÃ£o' });
  }
});

// 4. Mercado Pago: OAuth Callback
app.post('/api/mercadopago/auth', async (req, res) => {
  try {
    const { code } = req.body;

    if (!code) {
      return res.status(400).json({ error: 'CÃ³digo de autorizaÃ§Ã£o nÃ£o fornecido' });
    }

    const response = await axios.post('https://api.mercadopago.com/oauth/token', {
      client_secret: MP_CLIENT_SECRET,
      client_id: MP_CLIENT_ID,
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: MP_REDIRECT_URI
    });

    const { access_token, refresh_token, user_id } = response.data;

    await supabase.from('app_config').upsert({ key: 'mp_owner_token', value: access_token, updated_at: new Date().toISOString() });
    await supabase.from('app_config').upsert({ key: 'mp_owner_refresh_token', value: refresh_token, updated_at: new Date().toISOString() });
    await supabase.from('app_config').upsert({ key: 'mp_owner_user_id', value: user_id.toString(), updated_at: new Date().toISOString() });

    console.log('âœ“ Mercado Pago connected successfully for user:', user_id);
    res.json({ success: true, message: 'Mercado Pago conectado com sucesso!' });
  } catch (error) {
    console.error('MP Auth Error:', error.response?.data || error.message);
    res.status(500).json({ error: 'Falha ao autenticar com Mercado Pago' });
  }
});

// 5. Mercado Pago: Create Preference (Payment)
app.post('/api/subscribe', async (req, res) => {
  try {
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { planId } = req.body;
    const { data: plan } = await supabase.from('plan_settings').select('*').eq('id', planId).single();
    if (!plan) return res.status(404).json({ error: 'Plano nÃ£o encontrado' });

    const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
    const ownerToken = config?.value || MP_ACCESS_TOKEN;

    if (!ownerToken) {
      return res.status(500).json({ error: 'Sistema de pagamento nÃ£o configurado.' });
    }

    const preference = {
      items: [{
        title: `Plano ${planId.toUpperCase()} - Flow Designer`,
        description: `Assinatura mensal do plano ${planId.toUpperCase()}`,
        unit_price: Number(plan.price),
        quantity: 1,
        currency_id: 'BRL'
      }],
      payer: { email: user.email },
      back_urls: {
        success: `${req.headers.origin}/?status=success&plan=${planId}`,
        failure: `${req.headers.origin}/?status=failure`,
        pending: `${req.headers.origin}/?status=pending`
      },
      auto_return: 'approved',
      external_reference: `${user.id}|${planId}`,
      notification_url: `${process.env.VITE_API_URL || 'http://localhost:3001'}/api/mercadopago/webhook`,
      statement_descriptor: 'FLOW DESIGNER'
    };

    const ownerClient = new mercadopago.MercadoPagoConfig({ accessToken: ownerToken });
    const preferenceClient = new mercadopago.Preference(ownerClient);
    const mpResponse = await preferenceClient.create({ body: preference });

    console.log('âœ“ Payment preference created:', mpResponse.id);
    res.json({ paymentUrl: mpResponse.init_point });

  } catch (error) {
    console.error('Subscribe Error:', error);
    res.status(500).json({ error: 'Falha ao criar preferÃªncia de pagamento' });
  }
});

// 6. Mercado Pago: Webhook
const processedPayments = new Set();
app.post('/api/mercadopago/webhook', async (req, res) => {
  const { type, data } = req.body;
  res.status(200).send('OK');

  if (type === 'payment') {
    try {
      const paymentId = data.id;
      if (processedPayments.has(paymentId)) return;

      const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
      const ownerToken = config?.value || MP_ACCESS_TOKEN;

      const ownerClient = new mercadopago.MercadoPagoConfig({ accessToken: ownerToken });
      const paymentClient = new mercadopago.Payment(ownerClient);
      const payment = await paymentClient.get({ id: paymentId });

      if (payment.status === 'approved') {
        const externalRef = payment.external_reference;
        const [userId, planId] = externalRef.split('|');

        let newRole = 'free';
        if (planId === 'starter') newRole = 'starter';
        if (planId === 'pro') newRole = 'pro';

        await supabase.from('profiles').update({ role: newRole }).eq('id', userId);
        processedPayments.add(paymentId);
        console.log(`âœ“ Payment approved: ${paymentId} | User: ${userId} | Plan: ${planId}`);
      }
    } catch (error) {
      console.error('Webhook Error:', error);
    }
  }
});

// Admin User Management Routes
app.get('/api/admin/users', async (req, res) => {
  try {
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    // Verify if user is owner
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    if (profile?.role !== 'owner') return res.status(403).json({ error: 'Acesso negado' });

    // Fetch all profiles with usage data
    const { data: profiles, error } = await supabase
      .from('profiles')
      .select(`
                *,
                user_usage (
                    images_generated
                )
            `)
      .order('created_at', { ascending: false });

    if (error) throw error;

    const usersWithUsage = profiles.map(p => ({
      ...p,
      images_generated: p.user_usage?.[0]?.images_generated || 0
    }));

    res.json(usersWithUsage);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Erro ao buscar usuÃ¡rios' });
  }
});

app.post('/api/admin/create-user', async (req, res) => {
  try {
    const requester = await getAuthUser(req);
    if (!requester) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', requester.id).single();
    if (profile?.role !== 'owner') return res.status(403).json({ error: 'Acesso negado' });

    const { email, password, firstName, lastName, plan } = req.body;

    // Create auth user
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          first_name: firstName,
          last_name: lastName,
          role: plan // Set initial role
        }
      }
    });

    if (authError) throw authError;

    res.json({ success: true, user: authData.user });

  } catch (error) {
    console.error('Error creating user:', error);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/admin/users/:id', async (req, res) => {
  try {
    const requester = await getAuthUser(req);
    if (!requester) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', requester.id).single();
    if (profile?.role !== 'owner') return res.status(403).json({ error: 'Acesso negado' });

    const { id } = req.params;

    // Delete from auth
    const { error } = await supabase.auth.admin.deleteUser(id);

    if (error) throw error;

    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/mp-status', async (req, res) => {
  try {
    const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
    res.json({ connected: !!config?.value });
  } catch (error) {
    res.json({ connected: false });
  }
});


app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});
