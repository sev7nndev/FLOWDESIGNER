const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { createClient } = require('@supabase/supabase-js');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const mercadopago = require('mercadopago');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');

dotenv.config({ path: '.env.local' });
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// --- Configuration ---
const SUPABASE_URL = process.env.VITE_SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const MP_ACCESS_TOKEN = process.env.MERCADO_PAGO_ACCESS_TOKEN;
const MP_CLIENT_ID = process.env.MERCADO_PAGO_CLIENT_ID;
const MP_CLIENT_SECRET = process.env.MERCADO_PAGO_CLIENT_SECRET;
const MP_REDIRECT_URI = process.env.MERCADO_PAGO_REDIRECT_URI || 'http://localhost:3000/saas-panel';

console.log("ðŸš€ Flow Designer Backend Starting...");
console.log("SUPABASE_URL:", SUPABASE_URL ? "âœ“" : "âœ—");
console.log("SUPABASE_SERVICE_KEY:", SUPABASE_SERVICE_KEY ? "âœ“" : "âœ—");
console.log("GEMINI_API_KEY:", GEMINI_API_KEY ? "âœ“" : "âœ—");
console.log("MP_CLIENT_ID:", MP_CLIENT_ID ? "âœ“" : "âœ—");

// Initialize Clients
if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
  console.error("âŒ Missing Supabase credentials. Check .env.local");
}
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

// Mercado Pago Configuration (v2 SDK)
const mpClient = new mercadopago.MercadoPagoConfig({ accessToken: MP_ACCESS_TOKEN });

// --- Middleware ---
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'DELETE', 'PUT', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json({ limit: '10mb' }));

// --- Helpers ---
const getAuthUser = async (req) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return null;
  const token = authHeader.split(' ')[1];
  const { data: { user }, error } = await supabase.auth.getUser(token);
  if (error || !user) return null;
  return user;
};

// --- Routes ---

// 1. AI: Professional Image Generation with Google Imagen (REST API)
app.post('/api/generate', async (req, res) => {
  try {
    console.log('ðŸŽ¨ Generation request received');
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });
    console.log('âœ“ User authenticated:', user.id);

    const { promptInfo, artStyle } = req.body;
    console.log('ðŸ“ Prompt info:', promptInfo);

    // Fetch user role
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    const role = profile?.role || 'free';
    console.log('ðŸ‘¤ User role:', role);

    // UNLIMITED GENERATION FOR OWNER AND DEV
    const hasUnlimitedGeneration = role === 'owner' || role === 'dev';

    if (!hasUnlimitedGeneration) {
      // Check Quota for regular users
      const { data: usageData, error: usageError } = await supabase
        .from('user_usage')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (usageError && usageError.code !== 'PGRST116') {
        console.error('âŒ Usage error:', usageError);
        throw usageError;
      }

      // Fetch plan limits - CORRECT VALUES: 3/20/50
      const limit = role === 'pro' ? 50 : (role === 'starter' ? 20 : 3);
      console.log(`ðŸ“Š Quota: ${usageData?.images_generated || 0}/${limit}`);

      if (usageData && usageData.images_generated >= limit) {
        return res.status(403).json({
          error: 'Limite de geraÃ§Ã£o atingido.',
          quotaStatus: 'BLOCKED',
          usage: usageData.images_generated,
          plan: role
        });
      }
    } else {
      console.log('âœ¨ Unlimited generation enabled for', role);
    }

    // STAGE 1: THE DIRECTOR (Prompt Enhancement & Style Decision)
    console.log('ðŸ§  Stage 1: The Director is planning the artwork...');

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

        const directorPrompt = `You are a LEGENDARY Creative Director with 20+ years creating AWARD-WINNING commercial designs for Fortune 500 companies. Your designs are PHOTOREALISTIC, CINEMATIC, and BREATHTAKING.

CLIENT BRIEFING:
- Company: ${promptInfo.companyName}
- Business Type/Details: ${promptInfo.details}
- Location: ${promptInfo.addressCity || 'Brazil'}
- Phone: ${promptInfo.phone || 'Contact info'}
- Full Address: ${promptInfo.addressStreet}, ${promptInfo.addressNumber} - ${promptInfo.addressNeighborhood}

YOUR MISSION - CREATE A MASTERPIECE:

1. **ANALYZE THE NICHE** and choose the PERFECT visual style:
   - Automotive/Mechanic â†’ Dark dramatic lighting, metallic chrome effects, orange/blue neon accents, realistic car renders, tools with depth
   - Tech/Digital â†’ Futuristic cyberpunk, circuit board patterns, holographic UI elements, cyan/blue neon lights, 3D metallic logos
   - Food/Restaurant â†’ Warm cinematic lighting, steam effects, photorealistic food close-ups, rustic or modern depending on cuisine
   - Events/Party â†’ Explosive energy, confetti, dramatic spotlights, vibrant neon colors, crowd silhouettes, 3D text with glow
   - Beauty/Fashion â†’ Soft glamour lighting, bokeh effects, elegant typography, premium gold/rose gold accents
   - Sports â†’ Dynamic action shots, team colors, stadium atmosphere, dramatic shadows, energetic composition

2. **COMPOSITION RULES** (CRITICAL):
   - Use RULE OF THIRDS for visual balance
   - Create DEPTH with foreground, midground, background layers
   - Add ATMOSPHERIC EFFECTS: smoke, fog, light rays, particles, sparks, neon glow
   - Include REALISTIC PRODUCTS/OBJECTS relevant to the business (cars, food, tools, etc.)
   - Use DRAMATIC LIGHTING: rim lighting, volumetric fog, lens flares, god rays, neon reflections

3. **TYPOGRAPHY SPECIFICATIONS**:
   - Company name: MASSIVE 3D metallic text with beveled edges, drop shadows, and glow effects
   - Use BOLD, IMPACTFUL fonts (like Impact, Bebas Neue, Montserrat Black)
   - Add DEPTH with extrusion, gradients, and reflections
   - Phone number: Clear, readable, with subtle glow or outline
   - Address: Smaller but legible at bottom

4. **COLOR PSYCHOLOGY**:
   - Automotive: Black, orange, metallic silver, dark blue
   - Tech: Dark blue, cyan, electric blue, white, carbon fiber texture
   - Food: Warm oranges, reds, browns, golden hour lighting
   - Events: Vibrant multi-color (pink, purple, yellow, cyan), high saturation
   - Luxury: Gold, black, deep purple, champagne

5. **TECHNICAL SPECIFICATIONS**:
   - Resolution: 8K quality, ultra-detailed
   - Render style: Photorealistic CGI, Octane Render, Unreal Engine 5 quality
   - Lighting: Cinematic three-point lighting, HDR, ray-traced reflections
   - Effects: Motion blur (subtle), depth of field, chromatic aberration, film grain
   - Composition: Professional advertising poster, magazine cover quality

6. **MANDATORY ELEMENTS TO INCLUDE**:
   - Realistic product/service representation (actual cars for mechanic, food for restaurant, etc.)
   - Environmental context (workshop, kitchen, stadium, etc.)
   - Professional logo design integrated into composition
   - Contact information clearly visible
   - Brand colors and identity

OUTPUT FORMAT:
Write a SINGLE, ULTRA-DETAILED prompt for Google Imagen 4.0. Structure:

"[MAIN SCENE: Photorealistic description of environment and key objects], [LIGHTING: Specific light sources, colors, and effects], [COMPOSITION: Foreground/midground/background elements], [EFFECTS: Atmospheric effects like smoke, particles, glow], [TYPOGRAPHY: 3D text placement and style for '${promptInfo.companyName}'], [SECONDARY TEXT: Phone '${promptInfo.phone}' and location '${promptInfo.addressCity}'], [TECHNICAL: Camera angle, depth of field, render quality]. Ultra-detailed, 8K resolution, photorealistic CGI, Octane Render, cinematic lighting, professional advertising poster, award-winning design, trending on Behance and Dribbble."

CRITICAL RULES:
- Make it look like a R$50,000 professional design
- PHOTOREALISM is mandatory - no cartoons or illustrations
- Text must be PERFECTLY readable and integrated into the design
- Use BRAZILIAN PORTUGUESE for all text
- Include REALISTIC brand elements (logos, products, environments)
- Create EMOTIONAL IMPACT through lighting and composition

Return ONLY the final prompt, nothing else.`;

    let professionalPrompt;
    try {
      const result = await model.generateContent(directorPrompt);
      const response = await result.response;
      professionalPrompt = response.text().trim().replace(/```[\s\S]*?```/g, '').trim();
      console.log('âœ… Director\'s Vision:', professionalPrompt.substring(0, 100) + '...');
    } catch (geminiError) {
      console.error('âš ï¸ Director Failed:', geminiError.message);
      professionalPrompt = `Professional commercial flyer for ${promptInfo.companyName}. ${promptInfo.details}. Text: "${promptInfo.companyName}" and "${promptInfo.phone}". High quality, 8k.`;
    }

    // STAGE 2: THE ARTIST (Image Generation)
    const generateImage = async (prompt) => {
      console.log('ðŸŽ¨ Stage 2: The Artist is painting...');
      const imagenModel = 'imagen-4.0-generate-001';
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${imagenModel}:predict?key=${GEMINI_API_KEY}`;

      const response = await axios.post(url, {
        instances: [{ prompt }],
        parameters: { sampleCount: 1, aspectRatio: "1:1" }
      }, { headers: { 'Content-Type': 'application/json' } });

      const prediction = response.data.predictions?.[0];
      const b64 = prediction?.bytesBase64Encoded || prediction?.image?.bytesBase64Encoded;
      if (!b64) throw new Error('No image generated');
      return b64;
    };

    let imageBase64 = await generateImage(professionalPrompt);
    let finalPrompt = professionalPrompt;

    // STAGE 3: THE CRITIC (Vision Check & Retry)
    console.log('ðŸ§ Stage 3: The Critic is reviewing...');

    try {
      const criticModel = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

      const imagePart = {
        inlineData: {
          data: imageBase64,
          mimeType: "image/png",
        },
      };

      const criticPrompt = `Act as a Senior Design Critic. Review this generated flyer for "${promptInfo.companyName}".
      
      CHECKLIST:
      1. Is the text "${promptInfo.companyName}" visible and NOT cut off?
      2. Is the phone number "${promptInfo.phone}" visible?
      3. Is the aesthetic "Surreal/Professional"?
      
      If the image is BAD (text cut off, ugly, wrong text), reply with "REJECT: [Reason] | [Improved Prompt Suggestion]".
      If the image is GOOD, reply with "APPROVE".
      
      Be strict about text cutoff.`;

      const criticResult = await criticModel.generateContent([criticPrompt, imagePart]);
      const criticVerdict = criticResult.response.text().trim();
      console.log('ðŸ“ Critic Verdict:', criticVerdict);

      if (criticVerdict.startsWith('REJECT')) {
        console.log('âš ï¸ Image rejected! Retrying ONE time with improved instructions...');
        const improvement = criticVerdict.split('|')[1] || "Ensure text is centered and smaller to avoid cutoff.";

        finalPrompt = `${professionalPrompt}. IMPORTANT FIX: ${improvement.trim()}`;
        imageBase64 = await generateImage(finalPrompt);
        console.log('âœ… Retry complete.');
      } else {
        console.log('âœ… Image approved by Critic.');
      }

    } catch (criticError) {
      console.error('âš ï¸ Critic unavailable or failed, proceeding with first draft:', criticError.message);
    }

    // Final Processing
    const imageUrl = `data:image/png;base64,${imageBase64}`;

    console.log('ðŸ’¾ Saving masterpiece...');
    const { data: savedImage, error: saveError } = await supabase
      .from('images')
      .insert({
        user_id: user.id,
        prompt: finalPrompt,
        image_url: imageUrl,
        business_info: promptInfo
      })
      .select()
      .single();

    if (saveError) throw saveError;

    // âœ… FIX 1: Update Usage (CRITICAL - with proper error handling)
    if (!hasUnlimitedGeneration) {
      console.log('ðŸ“Š Updating usage counter for user:', user.id);

      const { data: usageData, error: fetchError } = await supabase
        .from('user_usage')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (fetchError && fetchError.code !== 'PGRST116') {
        console.error('âŒ Error fetching usage:', fetchError);
        throw new Error('Falha ao verificar uso atual');
      }

      if (usageData) {
        console.log(`ðŸ“ˆ Current usage: ${usageData.images_generated}, incrementing to ${usageData.images_generated + 1}`);
        const { error: updateError } = await supabase
          .from('user_usage')
          .update({
            images_generated: usageData.images_generated + 1,
            updated_at: new Date().toISOString()
          })
          .eq('user_id', user.id);

        if (updateError) {
          console.error('âŒ Error updating usage:', updateError);
          throw new Error('Falha ao atualizar contador de uso');
        }
        console.log('âœ… Usage updated successfully to:', usageData.images_generated + 1);
      } else {
        console.log('ðŸ“ Creating new usage record with count: 1');
        const { error: insertError } = await supabase
          .from('user_usage')
          .insert({
            user_id: user.id,
            images_generated: 1,
            cycle_start_date: new Date().toISOString()
          });

        if (insertError) {
          console.error('âŒ Error creating usage record:', insertError);
          throw new Error('Falha ao criar registro de uso');
        }
        console.log('âœ… Usage record created successfully');
      }
    } else {
      console.log('âœ¨ Unlimited user - skipping usage update');
    }

    res.json({ image: savedImage });

  } catch (error) {
    console.error('âŒ Generation error:', error);
    if (axios.isAxiosError(error)) {
      console.error('Axios Error Status:', error.response?.status);
      console.error('Axios Error Data:', JSON.stringify(error.response?.data, null, 2));
    }
    res.status(500).json({
      error: 'Falha ao gerar imagem: ' + (error.message || 'Erro desconhecido'),
      details: error.response?.data || error.message
    });
  }
});

// 2. Check Quota Endpoint
app.get('/api/check-quota', async (req, res) => {
  try {
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    const role = profile?.role || 'free';

    const { data: usageData } = await supabase
      .from('user_usage')
      .select('*')
      .eq('user_id', user.id)
      .single();

    const usageCount = usageData?.images_generated || 0;
    const limit = role === 'pro' ? 50 : (role === 'starter' ? 20 : 3);

    let status = 'OK';
    if (usageCount >= limit) status = 'BLOCKED';
    else if (usageCount >= limit * 0.8) status = 'NEAR_LIMIT';

    if (role === 'owner' || role === 'dev') status = 'OK';

    res.json({
      status,
      usage: {
        user_id: user.id,
        plan_id: role,
        cycle_start_date: new Date().toISOString(),
        current_usage: usageCount
      },
      plan: {
        id: role,
        price: 0,
        max_images_per_month: limit
      },
      plans: [],
      message: status === 'BLOCKED' ? 'Limite de geraÃ§Ã£o atingido' : 'Tudo certo!'
    });

  } catch (error) {
    console.error('Quota Check Error:', error);
    res.status(500).json({ error: 'Erro ao verificar cota' });
  }
});

// 3. Mercado Pago: Admin Connect (OAuth)
app.get('/api/admin/mp-connect', async (req, res) => {
  try {
    if (!MP_CLIENT_ID || !MP_REDIRECT_URI) {
      return res.status(500).json({ error: 'Mercado Pago nÃ£o configurado' });
    }

    const state = uuidv4();
    const url = `https://auth.mercadopago.com/authorization?client_id=${MP_CLIENT_ID}&response_type=code&platform_id=mp&state=${state}&redirect_uri=${encodeURIComponent(MP_REDIRECT_URI)}`;

    res.json({ connectUrl: url });
  } catch (error) {
    console.error('MP Connect Error:', error);
    res.status(500).json({ error: 'Erro ao gerar URL de conexÃ£o' });
  }
});

// 4. Mercado Pago: OAuth Callback
app.post('/api/mercadopago/auth', async (req, res) => {
  try {
    const { code } = req.body;

    if (!code) {
      return res.status(400).json({ error: 'CÃ³digo de autorizaÃ§Ã£o nÃ£o fornecido' });
    }

    const response = await axios.post('https://api.mercadopago.com/oauth/token', {
      client_secret: MP_CLIENT_SECRET,
      client_id: MP_CLIENT_ID,
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: MP_REDIRECT_URI
    });

    const { access_token, refresh_token, user_id } = response.data;

    await supabase.from('app_config').upsert({ key: 'mp_owner_token', value: access_token, updated_at: new Date().toISOString() });
    await supabase.from('app_config').upsert({ key: 'mp_owner_refresh_token', value: refresh_token, updated_at: new Date().toISOString() });
    await supabase.from('app_config').upsert({ key: 'mp_owner_user_id', value: user_id.toString(), updated_at: new Date().toISOString() });

    console.log('âœ“ Mercado Pago connected successfully for user:', user_id);
    res.json({ success: true, message: 'Mercado Pago conectado com sucesso!' });
  } catch (error) {
    console.error('MP Auth Error:', error.response?.data || error.message);
    res.status(500).json({ error: 'Falha ao autenticar com Mercado Pago' });
  }
});

// 5. Mercado Pago: Create Preference (Payment)
app.post('/api/subscribe', async (req, res) => {
  try {
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { planId } = req.body;
    const { data: plan } = await supabase.from('plan_settings').select('*').eq('id', planId).single();
    if (!plan) return res.status(404).json({ error: 'Plano nÃ£o encontrado' });

    const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
    const ownerToken = config?.value || MP_ACCESS_TOKEN;

    if (!ownerToken) {
      return res.status(500).json({ error: 'Sistema de pagamento nÃ£o configurado.' });
    }

    const preference = {
      items: [{
        title: `Plano ${planId.toUpperCase()} - Flow Designer`,
        description: `Assinatura mensal do plano ${planId.toUpperCase()}`,
        unit_price: Number(plan.price),
        quantity: 1,
        currency_id: 'BRL'
      }],
      payer: { email: user.email },
      back_urls: {
        success: `${req.headers.origin}/?status=success&plan=${planId}`,
        failure: `${req.headers.origin}/?status=failure`,
        pending: `${req.headers.origin}/?status=pending`
      },
      auto_return: 'approved',
      external_reference: `${user.id}|${planId}`,
      notification_url: `${process.env.VITE_API_URL || 'http://localhost:3001'}/api/mercadopago/webhook`,
      statement_descriptor: 'FLOW DESIGNER'
    };

    const ownerClient = new mercadopago.MercadoPagoConfig({ accessToken: ownerToken });
    const preferenceClient = new mercadopago.Preference(ownerClient);
    const mpResponse = await preferenceClient.create({ body: preference });

    console.log('âœ“ Payment preference created:', mpResponse.id);
    res.json({ paymentUrl: mpResponse.init_point });

  } catch (error) {
    console.error('Subscribe Error:', error);
    res.status(500).json({ error: 'Falha ao criar preferÃªncia de pagamento' });
  }
});

// 6. Mercado Pago: Webhook
const processedPayments = new Set();
app.post('/api/mercadopago/webhook', async (req, res) => {
  const { type, data } = req.body;
  res.status(200).send('OK');

  if (type === 'payment') {
    try {
      const paymentId = data.id;
      if (processedPayments.has(paymentId)) return;

      const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
      const ownerToken = config?.value || MP_ACCESS_TOKEN;

      const ownerClient = new mercadopago.MercadoPagoConfig({ accessToken: ownerToken });
      const paymentClient = new mercadopago.Payment(ownerClient);
      const payment = await paymentClient.get({ id: paymentId });

      if (payment.status === 'approved') {
        const externalRef = payment.external_reference;
        const [userId, planId] = externalRef.split('|');

        let newRole = 'free';
        if (planId === 'starter') newRole = 'starter';
        if (planId === 'pro') newRole = 'pro';

        await supabase.from('profiles').update({ role: newRole }).eq('id', userId);
        processedPayments.add(paymentId);
        console.log(`âœ“ Payment approved: ${paymentId} | User: ${userId} | Plan: ${planId}`);
      }
    } catch (error) {
      console.error('Webhook Error:', error);
    }
  }
});

// âœ… FIX 2: Admin User Management Routes (with owner/dev filter)
app.get('/api/admin/users', async (req, res) => {
  try {
    console.log('ðŸ“‹ Fetching users for owner panel...');
    const user = await getAuthUser(req);
    if (!user) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profileError) {
      console.error('âŒ Error fetching requester profile:', profileError);
      return res.status(500).json({ error: 'Erro ao verificar permissÃµes' });
    }

    if (profile?.role !== 'owner') {
      console.log('â›” Access denied for user:', user.id, 'Role:', profile?.role);
      return res.status(403).json({ error: 'Acesso negado' });
    }

    // Fetch all profiles EXCLUDING owner and dev
    console.log('ðŸ” Fetching all client profiles (excluding owner/dev)...');
    const { data: profiles, error } = await supabase
      .from('profiles')
      .select('*')
      .not('role', 'in', '("owner","dev")')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('âŒ Error fetching profiles:', error);
      throw error;
    }

    console.log(`âœ… Found ${profiles?.length || 0} client profiles`);

    // Fetch usage data separately to avoid JOIN issues
    const userIds = profiles.map(p => p.id);
    const { data: usageData, error: usageError } = await supabase
      .from('user_usage')
      .select('user_id, images_generated')
      .in('user_id', userIds);

    if (usageError) {
      console.warn('âš ï¸ Error fetching usage data (continuing without it):', usageError);
    }

    // Create a map for quick lookup
    const usageMap = new Map();
    if (usageData) {
      usageData.forEach(u => usageMap.set(u.user_id, u.images_generated));
    }

    // Combine profiles with usage data
    const usersWithUsage = profiles.map(p => ({
      id: p.id,
      email: p.email,
      first_name: p.first_name,
      last_name: p.last_name,
      role: p.role,
      created_at: p.created_at,
      images_generated: usageMap.get(p.id) || 0
    }));

    console.log('âœ… Returning', usersWithUsage.length, 'users to owner panel');
    res.json(usersWithUsage);
  } catch (error) {
    console.error('âŒ Error fetching users:', error);
    res.status(500).json({ error: 'Erro ao buscar usuÃ¡rios', details: error.message });
  }
});

app.post('/api/admin/create-user', async (req, res) => {
  try {
    const requester = await getAuthUser(req);
    if (!requester) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', requester.id).single();
    if (profile?.role !== 'owner') return res.status(403).json({ error: 'Acesso negado' });

    const { email, password, firstName, lastName, plan } = req.body;

    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          first_name: firstName,
          last_name: lastName,
          role: plan
        }
      }
    });

    if (authError) throw authError;

    res.json({ success: true, user: authData.user });

  } catch (error) {
    console.error('Error creating user:', error);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/admin/users/:id', async (req, res) => {
  try {
    const requester = await getAuthUser(req);
    if (!requester) return res.status(401).json({ error: 'NÃ£o autorizado' });

    const { data: profile } = await supabase.from('profiles').select('role').eq('id', requester.id).single();
    if (profile?.role !== 'owner') return res.status(403).json({ error: 'Acesso negado' });

    const { id } = req.params;

    const { error } = await supabase.auth.admin.deleteUser(id);

    if (error) throw error;

    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/mp-status', async (req, res) => {
  try {
    const { data: config } = await supabase.from('app_config').select('value').eq('key', 'mp_owner_token').single();
    res.json({ connected: !!config?.value });
  } catch (error) {
    res.json({ connected: false });
  }
});

// Only start server if run directly (local dev)
if (require.main === module) {
  app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on port ${PORT}`);
  });
}

module.exports = app;